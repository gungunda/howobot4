# Clean Architecture (Lite) — Thin Use Cases + Storage

> Target audience: junior–mid developers.  
> Goal: keep the **domain clean**, keep the **codebase observable**, and **minimize layers** without losing separation of concerns.  
> Layers: **UI → UseCases → Storage → Entities**.  
> Storage is a single concrete module (e.g., `localStorage`), without ports/adapters/DI.  
> Use Cases are thin orchestration scripts that express user intent.

---

## 1) Core Principles (Pragmatic Clean Architecture)

1. **Domain first.**  
   Business rules (invariants) live in **Entities**. They are framework-agnostic and storage-agnostic.

2. **Use cases orchestrate, entities validate.**  
   Use cases decide *when/why* we do something; entities decide *what is allowed* and *how the object changes*.

3. **Thin Use Cases + Storage (simplified Clean Architecture).**  
   Each Use Case is a small, readable function or class:
   - loads an entity from `Storage`,
   - calls domain methods on the entity,
   - saves it back using the same Storage module.

4. **Storage replaces full Repository/Adapter layers.**  
   It’s the single place that knows about `localStorage` and serialization.
   Other layers never touch persistence directly.

5. **Thin UI.**  
   UI renders, gathers input, calls **Use Cases**, and re-renders.  
   No domain logic in UI; no state mutations outside Entities.

6. **No sideways dependencies.**  
   Data flow is one-way: `UI → UseCases → Storage → Entities`.  
   Entities never call back upward.

7. **Observability over cleverness.**  
   Keep call chains short and explicit. Prefer clear names over abstractions.

---

## 2) Minimal Project Structure

```
src/
  entities/                 # Domain models (no storage, no UI)
    Task.js
  storage/                  # Concrete storage (localStorage-based)
    TaskStorage.js
  usecases/                 # Thin orchestration scripts
    RenameTaskUseCase.js
    UpdateTaskProgressUseCase.js
    CreateTaskUseCase.js
  ui/                       # Thin UI
    pages/
      TaskEditor/
        view.js             # DOM + event handlers (render & bind)
        presenter.js        # Small coordinator that calls use cases
  app.js                    # Bootstrap (mount UI, register routes if any)
```

**Dependency rule (strict):**
```
ui → usecases → storage → entities
```
No reverse imports. No entity importing UI or storage.

---

## 3) Entities — Domain Objects with Invariants

- Plain classes/functions that encode **valid state** + **valid transitions**.
- Expose domain methods like `rename`, `setPlannedMinutes`, `updateProgress`, etc.
- Throw errors if constraints are violated.

**Checklist (Entities):**
- [ ] No `fetch`, no `localStorage`, no DOM imports.
- [ ] Validate input and maintain invariants.
- [ ] Keep constructors consistent and safe.
- [ ] Keep methods small and intention-revealing.

**Example:**
```js
// entities/Task.js
export class Task {
  constructor({ id, title, plannedMinutes = 0, donePercent = 0 }) {
    if (!title || !title.trim()) throw new Error('Task must have a title')
    if (plannedMinutes < 0) throw new Error('plannedMinutes cannot be negative')
    if (donePercent < 0 || donePercent > 100) throw new Error('donePercent must be 0..100')
    this.id = id
    this.title = title.trim()
    this.plannedMinutes = plannedMinutes
    this.donePercent = donePercent
  }
  rename(newTitle) {
    if (!newTitle || !newTitle.trim()) throw new Error('Title cannot be empty')
    this.title = newTitle.trim()
  }
  setPlannedMinutes(minutes) {
    if (minutes <= 0) throw new Error('Time must be positive')
    this.plannedMinutes = minutes
  }
  updateProgress(percent) {
    if (percent < 0 || percent > 100) throw new Error('Progress must be 0..100')
    this.donePercent = percent
  }
}
```

---

## 4) Storage — Concrete Module (LocalStorage)

- A single module that knows how to **load/save** Entities and perform serialization.
- Provides a clear, small API: `getById`, `save`, `create`, `list`.
- Hides persistence details from other layers.

**Checklist (Storage):**
- [ ] Only place where `localStorage` is used.
- [ ] Converts JSON ↔ Entities.
- [ ] Never bypass entity invariants (always mutate through entity methods).

**Example:**
```js
// storage/TaskStorage.js
import { Task } from '../entities/Task.js'

const LS = typeof window !== 'undefined' ? window.localStorage : null
const KEY = id => `task_${id}`

export const TaskStorage = {
  toRecord(task) {
    return {
      id: task.id,
      title: task.title,
      plannedMinutes: task.plannedMinutes,
      donePercent: task.donePercent,
    }
  },
  fromRecord(rec) { return new Task(rec) },

  getById(id) {
    const raw = LS.getItem(KEY(id))
    if (!raw) throw new Error('Task not found')
    return this.fromRecord(JSON.parse(raw))
  },
  save(task) {
    LS.setItem(KEY(task.id), JSON.stringify(this.toRecord(task)))
    return task
  },
  create({ id, title, plannedMinutes = 0, donePercent = 0 }) {
    if (LS.getItem(KEY(id))) throw new Error('Task exists')
    const t = new Task({ id, title, plannedMinutes, donePercent })
    return this.save(t)
  },
  list() {
    const out = []
    for (let i = 0; i < LS.length; i++) {
      const k = LS.key(i)
      if (k?.startsWith('task_')) out.push(this.fromRecord(JSON.parse(LS.getItem(k))))
    }
    return out
  },
}
```

---

## 5) Use Cases — Thin, Readable Orchestration

- Express a single user intent (rename task, update progress, etc.).
- Read entity from Storage → call domain method → save → return result.
- Each file handles one scenario; easy to scan and test manually.

**Example:**
```js
// usecases/RenameTaskUseCase.js
import { TaskStorage } from '../storage/TaskStorage.js'

export class RenameTaskUseCase {
  static execute({ taskId, newTitle }) {
    const task = TaskStorage.getById(taskId)
    task.rename(newTitle)         // domain invariant inside Entity
    return TaskStorage.save(task)
  }
}
```

```js
// usecases/UpdateTaskProgressUseCase.js
import { TaskStorage } from '../storage/TaskStorage.js'

export class UpdateTaskProgressUseCase {
  static execute({ taskId, percent }) {
    const task = TaskStorage.getById(taskId)
    task.updateProgress(percent)
    return TaskStorage.save(task)
  }
}
```

```js
// usecases/CreateTaskUseCase.js
import { TaskStorage } from '../storage/TaskStorage.js'

export class CreateTaskUseCase {
  static execute({ id, title, plannedMinutes = 0 }) {
    return TaskStorage.create({ id, title, plannedMinutes, donePercent: 0 })
  }
}
```

**Pattern:** *load → mutate via Entity → save → return*

---

## 6) UI — Thin Presenter + View

- **Presenter:** handles user actions, calls Use Cases, returns view models.
- **View:** renders DOM, binds events, and reacts to results.
- **UI never manipulates entities directly.**

**Example (Presenter):**
```js
// ui/pages/TaskEditor/presenter.js
import { RenameTaskUseCase } from '../../../usecases/RenameTaskUseCase.js'
import { UpdateTaskProgressUseCase } from '../../../usecases/UpdateTaskProgressUseCase.js'
import { TaskStorage } from '../../../storage/TaskStorage.js'

export const TaskEditorPresenter = {
  load(taskId) {
    const t = TaskStorage.getById(taskId)
    return { id: t.id, title: t.title, minutes: t.plannedMinutes, progress: t.donePercent }
  },
  rename(taskId, newTitle) {
    const t = RenameTaskUseCase.execute({ taskId, newTitle })
    return { id: t.id, title: t.title, minutes: t.plannedMinutes, progress: t.donePercent }
  },
  setProgress(taskId, percent) {
    const t = UpdateTaskProgressUseCase.execute({ taskId, percent })
    return { id: t.id, title: t.title, minutes: t.plannedMinutes, progress: t.donePercent }
  },
}
```

**Example (View):**
```js
// ui/pages/TaskEditor/view.js
import { TaskEditorPresenter as P } from './presenter.js'

export function mountTaskEditor(root, taskId) {
  function render(model) {
    root.innerHTML = `
      <h2>Task editor</h2>
      <input id="title" value="${model.title}">
      <input id="progress" type="number" value="${model.progress}">
      <button id="saveTitle">Save title</button>
      <button id="saveProgress">Save progress</button>
    `
    root.querySelector('#saveTitle').onclick = () => {
      try { render(P.rename(taskId, root.querySelector('#title').value)) }
      catch (e) { alert(e.message) }
    }
    root.querySelector('#saveProgress').onclick = () => {
      try { render(P.setProgress(taskId, +root.querySelector('#progress').value)) }
      catch (e) { alert(e.message) }
    }
  }
  render(P.load(taskId))
}
```

---

## 7) Error Handling & Validation Strategy

- **Entities** throw on invariant violations → caught by UI and shown to the user.  
- **Storage** throws on `not found` or duplicate ID → caught by UI as well.  
- Error messages must be clear and actionable (“Title cannot be empty”).

Optional helper:
```js
export const tryCall = (fn, ...args) => {
  try { return { ok: true, value: fn(...args) } }
  catch (e) { return { ok: false, error: e } }
}
```

---

## 8) Naming & Conventions

- **Entities:** nouns (`Task`), domain verbs as methods (`rename`, `updateProgress`).  
- **Storage:** `*Storage.js` with a small API (`getById`, `save`, `create`, `list`).  
- **Use Cases:** `VerbNounUseCase.js` with static `execute(input)` returning an entity or view model.  
- **UI:** `view.js` (DOM) and optional `presenter.js` (logic).  
- **Mapping:** JSON ↔ Entity conversions live in Storage only.  
- **Keys:** prefix keys (e.g., `task_${id}`) and centralize in Storage.

---

## 9) Migration Path (when MVP grows)

- Need cloud sync or multiple backends? Extract a Storage interface from `TaskStorage`, move it to `LocalStorageTaskRepository`, and add another implementation (e.g., `ApiTaskRepository`).  
- Use Cases getting complex? Split them or add validators/helpers.  
- UI expanding? Componentize views or introduce a minimal router.

**Rule of thumb:** start simple; add abstraction only when real pressure appears.

---

## 10) Data Flow Summary (TL;DR)

1. **UI** collects intent → calls **UseCase.execute()**  
2. **UseCase** loads entity via **Storage**  
3. **Entity** validates and updates its state  
4. **UseCase** saves entity back through **Storage**  
5. **UI** re-renders using the returned data  

Short path, clear rules, clean domain, high observability.
