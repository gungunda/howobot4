# Гайд по комментированию кода (JSDoc, русскоязычные докстринги)

> Цель: единый стиль документирования для проектов с архитектурой **UI → UseCases → Storage → Entities**.  
> Результат: из комментариев JSDoc автоматически генерируется HTML‑документация (портал API).  
> Язык комментариев: **русский**. Синтаксис — **JSDoc**.

---

## 1) Принципы документирования

1. **Документируем намерение, а не реализацию.** Опиши «зачем существует функция/класс», «какой контракт она обещает».  
2. **Публичное — документируем всегда.** Экспортируемые функции/классы/типы — обязательно с JSDoc.  
3. **Кратко и последовательно.** Лаконичные формулировки, единый словарь терминов.  
4. **Контракты > детали.** Фиксируем параметры, возврат, возможные ошибки, инварианты.  
5. **Документация рядом с кодом.** Комментарии — в том же файле, над объявлением.  
6. **Слои — своей лексикой.**  
   - **Entities:** инварианты, допустимые переходы состояния.  
   - **UseCases:** сценарий (намерение пользователя), вход/выход.  
   - **Storage:** сериализация, чтение/запись, гарантии данных.  
   - **UI:** события, модель представления, ограничения UX.  
7. **Актуальность важнее полноты.** Меняется контракт — сразу обнови JSDoc.  

---

## 2) Базовые теги JSDoc (используемые)

| Тег | Назначение | Пример |
|-----|------------|--------|
| `@file` | Описание файла целиком | `/** @file TaskStorage.js */` |
| `@module` | Имя модуля (логическая единица) | `@module storage/TaskStorage` |
| `@param {Тип} имя описание` | Параметр функции | `@param {string} id Идентификатор задачи` |
| `@returns {Тип} описание` | Возвращаемое значение | `@returns {number} Доля 0..1` |
| `@throws {Error} причина` | Возможные исключения | `@throws {Error} Если не найдено` |
| `@typedef {Object} Имя` | Определение структурного типа | `@typedef {Object} TaskRecord` |
| `@property {Тип} поле` | Поле `typedef` | `@property {string} id` |
| `@example` | Пример использования | см. ниже |
| `@private` | Не предназначено для публичного API | `/** @private */` |
| `@deprecated` | Устаревшее API | `@deprecated Используйте ...` |

> Примечание: ссылки на типы из других файлов — через `import('путь').Тип`.

---

## 3) Шаблоны комментариев по слоям

### 3.1. Файл‑модуль (шапка)
```js
/**
 * @file TaskStorage.js
 * @module storage/TaskStorage
 * @description Конкретное хранилище для сущностей Task на базе localStorage.
 * Единственная точка доступа к сериализации и персистентности.
 */
```

### 3.2. Entities (доменная модель)
```js
/**
 * @file Task.js
 * @module entities/Task
 * @description Доменная сущность: хранит инварианты и допустимые переходы состояния.
 */

export class Task {
  /**
   * Создать экземпляр задачи.
   * @param {Object} args
   * @param {string} args.id Уникальный идентификатор
   * @param {string} args.title Название задачи (не пустое)
   * @param {number} [args.plannedMinutes=0] Запланированная длительность (мин)
   * @param {number} [args.donePercent=0] Прогресс 0..100
   * @throws {Error} Если нарушены инварианты (пустой заголовок, неверные границы)
   */
  constructor({ id, title, plannedMinutes = 0, donePercent = 0 }) { /* ... */ }

  /**
   * Переименовать задачу.
   * @param {string} newTitle Новое название (не пустое)
   * @throws {Error} Если название пустое
   */
  rename(newTitle) { /* ... */ }

  /**
   * Установить запланированное время.
   * @param {number} minutes Положительное целое количество минут
   * @throws {Error} Если minutes <= 0
   */
  setPlannedMinutes(minutes) { /* ... */ }

  /**
   * Обновить прогресс.
   * @param {number} percent Диапазон 0..100
   * @throws {Error} Если percent вне диапазона
   */
  updateProgress(percent) { /* ... */ }
}
```

### 3.3. Storage (локальное хранилище)
```js
/**
 * Простой JSON‑запись для персистентности.
 * @typedef {Object} TaskRecord
 * @property {string} id
 * @property {string} title
 * @property {number} plannedMinutes
 * @property {number} donePercent
 */

/**
 * Получить localStorage браузера.
 * @private
 * @returns {Storage}
 * @throws {Error} Если выполняется вне браузера
 */
function getStorage() { /* ... */ }

/** @private */
const KEY = (id) => `task_${id}`

export const TaskStorage = {
  /**
   * Преобразовать сущность в JSON‑запись.
   * @param {import('../entities/Task.js').Task} task
   * @returns {TaskRecord}
   */
  toRecord(task) { /* ... */ },

  /**
   * Восстановить сущность из JSON‑записи.
   * @param {TaskRecord} rec
   * @returns {import('../entities/Task.js').Task}
   */
  fromRecord(rec) { /* ... */ },

  /**
   * Прочитать задачу по id.
   * @param {string} id
   * @returns {import('../entities/Task.js').Task}
   * @throws {Error} Если запись не найдена
   * @example
   * const t = TaskStorage.getById('42')
   * console.log(t.title)
   */
  getById(id) { /* ... */ },

  /**
   * Сохранить сущность.
   * @param {import('../entities/Task.js').Task} task
   * @returns {import('../entities/Task.js').Task} Та же сущность (для чейнинга)
   * @example
   * const t = TaskStorage.getById('42')
   * t.rename('Алгебра'); TaskStorage.save(t)
   */
  save(task) { /* ... */ },

  /**
   * Создать новую задачу (ошибка, если id уже существует).
   * @param {Object} input
   * @param {string} input.id
   * @param {string} input.title
   * @param {number} [input.plannedMinutes=0]
   * @param {number} [input.donePercent=0]
   * @returns {import('../entities/Task.js').Task}
   * @throws {Error} Если id существует или нарушены инварианты
   */
  create({ id, title, plannedMinutes = 0, donePercent = 0 }) { /* ... */ },

  /**
   * Получить список всех задач.
   * @returns {Array<import('../entities/Task.js').Task>}
   */
  list() { /* ... */ },
}
```

### 3.4. Use Cases (тонкие сценарии)
```js
/**
 * @file RenameTaskUseCase.js
 * @module usecases/RenameTaskUseCase
 * @description Тонкий сценарий: прочитать → изменить через Entity → сохранить → вернуть.
 */

import { TaskStorage } from '../storage/TaskStorage.js'

/**
 * Входные данные сценария.
 * @typedef {Object} RenameTaskInput
 * @property {string} taskId
 * @property {string} newTitle
 */

/**
 * Переименовать задачу по идентификатору.
 * @param {RenameTaskInput} input
 * @returns {import('../entities/Task.js').Task} Обновлённая сущность
 * @throws {Error} Если задача не найдена или название некорректно
 * @example
 * const updated = RenameTaskUseCase.execute({ taskId: '42', newTitle: 'Алгебра' })
 * console.log(updated.title) // "Алгебра"
 */
export class RenameTaskUseCase {
  static execute({ taskId, newTitle }) {
    const task = TaskStorage.getById(taskId)
    task.rename(newTitle)
    return TaskStorage.save(task)
  }
}
```

### 3.5. UI (презентер и вью)

**Presenter (координатор):**
```js
/**
 * @file presenter.js
 * @module ui/TaskEditor/presenter
 * @description Координатор экрана: вызывает UseCases и возвращает модель представления (view model).
 */

import { RenameTaskUseCase } from '../../../usecases/RenameTaskUseCase.js'
import { TaskStorage } from '../../../storage/TaskStorage.js'

export const TaskEditorPresenter = {
  /**
   * Загрузить модель представления задачи.
   * @param {string} taskId
   * @returns {{ id: string, title: string, minutes: number, progress: number }}
   */
  load(taskId) {
    const t = TaskStorage.getById(taskId)
    return { id: t.id, title: t.title, minutes: t.plannedMinutes, progress: t.donePercent }
  },

  /**
   * Переименовать задачу и вернуть обновлённую модель.
   * @param {string} taskId
   * @param {string} newTitle
   * @returns {{ id: string, title: string, minutes: number, progress: number }}
   */
  rename(taskId, newTitle) {
    const t = RenameTaskUseCase.execute({ taskId, newTitle })
    return { id: t.id, title: t.title, minutes: t.plannedMinutes, progress: t.donePercent }
  },
}
```

**View (DOM‑логика):**
```js
/**
 * @file view.js
 * @module ui/TaskEditor/view
 * @description Отрисовка DOM и связывание событий. Доменные правила не реализуются во View.
 */

import { TaskEditorPresenter as P } from './presenter.js'

/**
 * Смонтировать редактор задачи.
 * @param {HTMLElement} root Контейнер для отрисовки
 * @param {string} taskId Идентификатор задачи
 */
export function mountTaskEditor(root, taskId) {
  function render(model) {
    root.innerHTML = `...`
    root.querySelector('#saveTitle').onclick = () => {
      try { render(P.rename(taskId, root.querySelector('#title').value)) }
      catch (e) { alert(e.message) }
    }
  }
  render(P.load(taskId))
}
```

---

## 4) Стиль и формулировки (правила)

- **Тон**: нейтральный, предметный, без жаргона.  
- **Формулировки**: начинать с глагола — «Создать», «Получить», «Сохранить», «Переименовать», «Обновить».  
- **Именование параметров**: коротко и по делу (`taskId`, `newTitle`, `minutes`, `percent`).  
- **Ошибки**: указывать, *когда и почему* выбрасываются (`@throws`).  
- **Примеры**: минимально самодостаточные (`@example`), на 3–7 строк.  
- **Типы**: для сложных объектов — `@typedef` + `@property`.  
- **Приватность**: внутренние утилиты помечать `@private` или убирать из экспорта.

---

## 5) Сборка документации (минимальная настройка)

**package.json**
```json
{
  "scripts": { "docs": "jsdoc -c jsdoc.json" },
  "devDependencies": { "jsdoc": "^4.0.0" }
}
```

**jsdoc.json**
```json
{
  "source": { "include": ["src"], "includePattern": ".js$" },
  "opts": { "destination": "docs", "recurse": true, "readme": "README.md" },
  "plugins": ["plugins/markdown"],
  "templates": { "default": { "includeDate": false } }
}
```

Запуск:
```bash
npm run docs
```
Готовый HTML‑сайт появится в `./docs`.

---

## 6) Мини‑шаблоны (копируй‑вставляй)

**Функция (общая):**
```js
/**
 * Краткое назначение.
 * @param {Тип} имя Описание
 * @param {Тип} [опционально] Описание
 * @returns {Тип} Что возвращает
 * @throws {Error} Условия возникновения ошибки
 * @example
 * const res = fn(arg)
 * console.log(res)
 */
function fn(arg) {}
```

**Класс (общая форма):**
```js
/**
 * Описание роли класса.
 */
class MyClass {
  /**
   * @param {Тип} p Описание
   */
  constructor(p) {}

  /**
   * Действие/метод.
   * @param {Тип} x
   * @returns {Тип}
   */
  do(x) {}
}
```

---

## 7) Частые ошибки и как их избежать

- **Повторяем код словами.** Пиши «зачем», а не «что делает каждая строка».  
- **Отсутствуют `@throws`.** Если метод бросает — это часть контракта.  
- **Смешение слоёв.** В UI — не описывать доменные инварианты; в Entities — не упоминать хранилище.  
- **Разные термины для одного понятия.** Утвердить словарь и его придерживаться.  
- **Отсутствует пример.** `@example` часто заменяет абзац текста.

---

## 8) TL;DR

1. Документируем **публичные API** в каждом файле.  
2. Пишем **на русском**, но в синтаксисе JSDoc.  
3. Следуем слоям: **Entities (инварианты)** → **Storage (сериализация/персист)** → **UseCases (тонкий сценарий)** → **UI (презентация)**.  
4. Отражаем контракты: `@param`, `@returns`, `@throws`, `@example`.  
5. Генерируем сайт `npm run docs` и кладём в `docs/` или на GitHub Pages.

— Конец гайда —
